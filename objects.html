<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="apple-touch-icon" sizes="180x180" href="./assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="./assets/favicon/site.webmanifest">
  <link rel="mask-icon" href="./assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <title>Arrays</title>
	<link rel="stylesheet" href="./css/srcery.min.css">
  <link rel="stylesheet" href="./css/style.css">
</head>
<body>
  <main>
    <section class="navigation">
      <nav class="nav">
        <ul class="nav__list">
					<li class="nav__item">
						<a class="nav__link" href="./index.html">Home</a>
					</li>
					<li class="nav__item">
						<a class="nav__link" href="./terms.html">Terms</a>
					</li>
					<li class="nav__item">
						<a class="nav__link" href="./task.html">JS Task</a>
					</li>
					<li class="nav__item">
						<a class="nav__link" href="./design.html">Design</a>
					</li>
          <li class="nav__item">
						<a class="nav__link" href="./cheats.html">Cheats</a>
					</li>
        </ul>
      </nav>
    </section>
		<section class="tasks">
			<div class="tasks__wrapper">
				<ul class="tasks__list">
					<li class="tasks__item">
						<a href="./variables.html" class="task__link">Variables</a>
					</li>
					<li class="tasks__item">
						<a href="./datatypes.html" class="task__link">Data types</a>
					</li>
					<li class="tasks__item">
						<a href="./conditions.html" class="task__link">Conditions</a>
					</li>
					<li class="tasks__item">
						<a href="./cycles.html" class="task__link">Cyclec</a>
					</li>
					<li class="tasks__item">
						<a href="./functions.html" class="task__link">Functions</a>
					</li>
					<li class="tasks__item">
						<a href="./operators.html" class="task__link">Operators</a>
					</li>
					<li class="tasks__item">
						<a href="./objects.html" class="task__link">Objects</a>
					</li>
				</ul>
			</div>
		</section>
		<section class="conditions">
			<div class="container">
				<div class="task">
					<h3 class="task__title hiden">Task № 1</h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Напишите код, выполнив задание из каждого пункта отдельной строой:</p>
							<p>1. Создайте пустой объект user;</p>
							<p>2. Добавьте свойство name со значением John;</p>
							<p>3. Добавьте свойство surname со значением Smith;</p>
							<p>4. Измените значение свойства name на Pete;</p>
							<p>5. Удалите свойство name из объекта.</p>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<pre>
								<code>
let user = {}
user.name = 'John'
user.surname = 'Smith'
user.name = 'Pete'
delete user.name
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № 2</h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Напишите функцию isEmpty(obj), которая возвращает true, если у объекта нет свойств, иначе false.</p>
							<p>Должно работать так:</p>
							<pre>
								<code>
let schedule = {}
console.log(isEmpty(schedule)) // true
schedule['8:30'] = 'get up'
console.log(isEmpty(schedule)) // false
								</code>
							</pre>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p>Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство.</p>
							</div>
							<pre>
								<code>
function isEmpty(obj) {
 for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false
  }
  return true
}
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № 3</h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Можно ли изменить объект, объявленный с помощью const? Как вы думаете?</p>
							<pre>
								<code>
const user = {
  name: 'John'
}

// это будет работать?
user.name = 'Pete'
								</code>
							</pre>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p>Конечно, это сработает без проблем.</p>
								<p>Объявление const защищает только саму переменную от изменений.</p>
								<p>Другими словами, user хранит ссылку на объект. И это не может быть изменено. Но содержимое объекта менять можно.</p>
							</div>
							<pre>
								<code>
const user = {
  name: 'John'
}

// Работает!
user.name = 'Pete'

// Ошибка
user = 123
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № 4</h3>
					<div class="task__condition">
						<div class="task__description">
							<p>У нас есть объект, в котором хранятся зарплаты нашей команды:</p>
							<pre>
								<code>
let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130,
}
								</code>
							</pre>
							<p>Напишите код для суммирования всех зарплат и сохраните результат в переменной sum. Должно получиться 390.</p>
							<p>Если объект salaries пуст, то результат должен быть 0.</p>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<pre>
								<code>
let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}

let sum = 0;
for (let key in salaries) {
  sum += salaries[key]
}

console.log(sum) // 390
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № 5</h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Создайте функцию multiplyNumeric(obj), которая умножает все числовые свойства объекта obj на 2.</p>
							<p>Пример:</p>
							<pre>
								<code>
// до вызова функции
let menu = {
  width: 200,
  height: 300,
  title: 'My menu'
}

multiplyNumeric(menu)

// после вызова функции
menu = {
  width: 400,
  height: 600,
  title: 'My menu'
}
								</code>
							</pre>
							<p>Обратите внимание, что multiplyNumeric не нужно ничего возвращать. Следует напрямую изменять объект.</p>
							<p>P.S. Используйте typeof для проверки, что значение свойства числовое.</p>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<pre>
								<code>
function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2
    }
  }
}
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № </h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Что выведет следующий код?</p>
							<pre>
								<code>
let fruits = ['Яблоки', 'Груша', 'Апельсин']

// добавляем новое значение в "копию"
let shoppingCart = fruits
shoppingCart.push('Банан')

// что в fruits?
console.log(fruits.length)
								</code>
							</pre>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p>В консоль выведется значение 4, потому, что массив - это объект. Обе переменные являются ссылками на один и тот же массив.</p>
							</div>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № </h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Давайте произведём 5 операций с массивом.</p>
							<p>Создайте массив styles с элементами «Джаз» и «Блюз».</p>
							<p>Добавьте «Рок-н-ролл» в конец.</p>
							<p>Замените значение в середине на «Классика». Ваш код для поиска значения в середине должен работать для массивов с любой длиной.</p>
							<p>Удалите первый элемент массива и покажите его.</p>
							<p>Вставьте «Рэп» и «Регги» в начало массива.</p>
							<p>Массив по ходу выполнения операций:</p>
							<pre>
								<code>
Джаз, Блюз
Джаз, Блюз, Рок-н-ролл
Джаз, Классика, Рок-н-ролл
Классика, Рок-н-ролл
Рэп, Регги, Классика, Рок-н-ролл
								</code>
							</pre>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<pre>
								<code>
let styles = ['Джаз', 'Блюз']
styles.push('Рок-н-ролл')
styles[Math.floor((styles.length - 1) / 2)] = 'Классика'
console.log(styles.shift())
styles.unshift('Рэп', 'Регги')
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № </h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Каков результат? Почему?</p>
							<pre>
								<code>
let arr = ['a', 'b']

arr.push(function() {
	console.log(this)
})

arr[2]()
								</code>
							</pre>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p>Вызов arr[2]() синтаксически – старый добрый obj[method](), в роли obj – arr, а в роли method – 2</p>
								<p>Итак, у нас есть вызов функции arr[2] как метода объекта. Соответственно, он получает в качестве this объект arr и выводит массив:</p>
								<p>У массива в итоге 3 элемента: сначала их было 2, плюс функция.</p>
							</div>
							<pre>
								<code>
let arr = ['a', 'b']

arr.push(function() {
	console.log(this)
})

arr[2]() // 'a','b',function
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № </h3>
					<div class="task__condition">
						<div class="task__description">
							<p>Напишите функцию sumInput(), которая:</p>
							<p>Просит пользователя ввести значения, используя prompt и сохраняет их в массив.</p>
							<p>Заканчивает запрашивать значения, когда пользователь введёт не числовое значение, пустую строку или нажмёт «Отмена».</p>
							<p>Подсчитывает и возвращает сумму элементов массива.</p>
							<p>P.S. Ноль 0 – считается числом, не останавливайте ввод значений при вводе «0».</p>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p>Обратите внимание на малозаметную, но важную деталь решения. Мы не преобразуем value в число сразу после prompt, потому что после value = +value мы не сможем отличить пустую строку (конец записи) от «0» (разрешённое число). Мы сделаем это позже.</p>
							</div>
							<pre>
								<code>
function sumInput() {

  let numbers = []

  while (true) {

    let value = prompt('Введите число', 0)

    // Прекращаем ввод?
    if (value === '' || value === null || !isFinite(value)) break

    numbers.push(+value)
  }

  let sum = 0
  for (let number of numbers) {
    sum += number
  }
return sum
}

console.log(sumInput())
								</code>
							</pre>
						</div>
					</div>
				</div>
				<div class="task">
					<h3 class="task__title hiden">Task № </h3>
					<div class="task__condition">
						<div class="task__description">
							<p>На входе массив чисел, например: arr = [1, -2, 3, 4, -9, 6].</p>
							<p>Task: найти непрерывный подмассив в arr, сумма элементов в котором максимальна.</p>
							<p>Функция getMaxSubSum(arr) должна возвращать эту сумму.</p>
							<p>Например:</p>
						</div>
						<pre>
							<code>
getMaxSubSum([-1, 2, 3, -9]) = 5 (сумма выделенных)
getMaxSubSum([2, -1, 2, 3, -9]) = 6
getMaxSubSum([-1, 2, 3, -9, 11]) = 11
getMaxSubSum([-2, -1, 1, 2]) = 3
getMaxSubSum([100, -9, 2, -3, 5]) = 100
getMaxSubSum([1, 2, 3]) = 6 (берём все)
							</code>
						</pre>
						<div class="task__description">
							<p>Если все элементы отрицательные – ничего не берём(подмассив пустой) и сумма равна «0»:</p>
						</div>
						<pre>
							<code>
getMaxSubSum([-1, -2, -3]) = 0
							</code>
						</pre>
						<div class="task__description">
							<p>Попробуйте придумать быстрое Solution: O(n<sup>2</sup>), а лучше за О(n) операций.</p>
						</div>
					</div>
					<div class="task__solution">
						<button class="collapsible">Solution:</button>
						<div class="content">
							<div class="task__description">
								<p><b>Медленное Solution:</b></p>
								<p>Можно посчитать все возможные подсуммы.</p>
								<p>Самый простой путь – посчитать суммы подмассивов, начиная с каждого элемента по очереди.</p>
								<p>Например, для [-1, 2, 3, -9, 11]:</p>
							</div>
							<pre>
								<code>
// Начиная с -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Начиная с 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Начиная с 3:
3
3 + (-9)
3 + (-9) + 11

// Начиная с -9
-9
-9 + 11

// Начиная с 11
11
								</code>
							</pre>
							<div class="task__description">
								<p>Реализуется с помощью вложенного цикла: внешний цикл проходит по элементам массива, а внутренний считает подсумму, начиная с текущего элемента.</p>
							</div>
							<pre>
								<code>
function getMaxSubSum(arr) {
  let maxSum = 0 // если элементов не будет - возвращаем 0

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j]
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum
}

console.log(getMaxSubSum([-1, 2, 3, -9])) // 5
console.log(getMaxSubSum([-1, 2, 3, -9, 11])) // 11
console.log(getMaxSubSum([-2, -1, 1, 2])) // 3
alert(getMaxSubSum([1, 2, 3])) // 6
console.log(getMaxSubSum([100, -9, 2, -3, 5])) // 100
								</code>
							</pre>
							<div class="task__description">
								<p>Это Solution имеет оценку сложности <a href="https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5" target="__blakn" style="color: rgb(13, 13, 189)">O(n2)</a>. Другими словами, если мы увеличим размер массива в 2 раза, время выполнения алгор	итма увеличится в 4 раза.</p>
								<p>Для больших массивов(1000, 10000 или больше элементов) такие алгоритмы могут приводить к серьёзным «тормозам».</p>
								<p><b>Быстрое Solution:</b></p>
								<p>Идём по массиву и накапливаем текущую частичную сумму элементов в переменной s. Если s в какой-то момент становится отрицательной – присваиваем s=0. Максимальный из всех s и будет ответом.</p>
								<p>Если объяснение недостаточно понятно, посмотрите на код, он вполне лаконичен:</p>
							</div>
							<pre>
								<code>
  function getMaxSubSum(arr) {
    let maxSum = 0
    let partialSum = 0
	
    for (let item of arr) { // для каждого элемента массива
      partialSum += item // добавляем значение элемента к partialSum
      maxSum = Math.max(maxSum, partialSum) // запоминаем максимум на данный момент
      if (partialSum < 0) partialSum = 0 // ноль если отрицательное
    }
	
    return maxSum;
  }
	
console.log(getMaxSubSum([-1, 2, 3, -9])) // 5
console.log(getMaxSubSum([-1, 2, 3, -9, 11])) // 11
console.log(getMaxSubSum([-2, -1, 1, 2])) // 3
console.log(getMaxSubSum([100, -9, 2, -3, 5])) // 100
console.log(getMaxSubSum([1, 2, 3])) // 6
console.log(getMaxSubSum([-1, -2, -3])) // 0
								</code>
							</pre>
							<div class="task__description">
								<p class="task__text"></p>
								<p>Больше информации об алгоритме тут: <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="__blakn" style="color: rgb(13, 13, 189)">Task поиска максимальной суммы подмассива</a>. Если всё ещё не очевидно как это работает, просмотрите алгоритм в примерах выше, это будет лучше всяких слов.</p>
							</div>
						</div>
					</div>
				</div>
			</div> <!-- Finish container -->
		</section>
  </main>
	<script src="./js/main.js"></script>
	<script src="./js/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</body>
</html>